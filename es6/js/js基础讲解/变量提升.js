// console.log(a);   
//  =>undefined，说明a已经存在，说明在js代码执行之前，还有其他的默认操作
// var a = 12;  
/*
  *变量提升：
    =>当栈内存（作用域）形成，js代码自上而下执行之前，浏览器首先会把所有带var/function关键字的进行提前声明或者定义

    =>声明  var a...    function add()...    默认值是undefined
    =>定义  a = 12 (定义其实就是赋值)

    =>[变量提升阶段]
    =>带var的只声明未定义；带function的则是把声明和赋值都完成了，赋值指的是将一大堆字符串赋值给函数

    
    => 变量提升只发生在当前作用域,例如开始加载页面只对全局作用域下的变量进行提升，因为此时函数中存储的都是字符串而已
    =》 在全局作用域下声明的变量叫全局变量，在私有作用域下声明的变量叫私有变量，带var，function的才是声明

    =》 浏览器很懒，当代码执行遇到创建函数这部分代码后，直接的跳过即可（因为在提升阶段就已经完成了函数的赋值操作了）
    =》 私有作用于形成后，也不是立即执行，而是先进行变量提升（变量提升前，先形参赋值）
    =》 在es3与es5语法规范中，只有全局作用域和函数执行的私有作用域（栈内存），其他大括号不会形成栈内存

*/

/*
  带var和不带var的区别
  在全局作用域下声明一个变量也相当于给window全局对象设置了一个属性，变量的值就是属性的值（私有作用于中声明的私有变量和window没啥关系） 
  在变量提升极阶段，在全局作用域中声明了一个变量A，此时就已经把A当作属性值赋值给window了
  用in来判断一个属性是不是属于某一个对象，只不过此时还没有给A赋值，默认undefined

  全局变量值修改，window属性值也跟着修改
  全局变量和window中的属性存在着“映射机制”，一个改变另一个也会改变
*/
 
// 不加var的本质是一个window下的属性
console.log(window.a); // undefined
console.log('a' in window); //=> false
a = 12;   //=> 其实是window.a = 12 的简写,不加var的本质是一个window下的属性
console.log(a); //=>12
console.log(window.a); //=>12

 